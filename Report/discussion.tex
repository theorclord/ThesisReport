\chapter{Discussion}
\label{sec:disc}
Here we will be discussing the design of the game, how the game is classified, the phases of the game and the results. We will also enter the topics of how PCG contributed to the game and what benefits it held. Later in this section we will discuss upon possible alternatives to our solution, along with team dynamics and issues that occurred.

\section{Basic design choices} 
In this section, we will elaborate on various different design choices during the development process. How certain aspects became as they did, and the reason behind the decisions for doing it so.

\subsection{Flavour text combinations}
Early on we knew that we would have to have the flavour text and events being shown to the players. Showing it to the player required generating connected strings in some form that could relate to what was happening in game terms.
Then the question ahead was: How would this be done?
We started by having fully formed lines of text for every possible outcome and event, but realized that this was not beneficial, and that it would not create enough diversity to work as a proof of concept. 
The initial fully formed event text were rigid and would not scale well with the implementation of more pieces or with new combinations. Each time a new piece would be added, or a piece removed, would require new events to be fully written to account for the change. 

All the text strings needed to be broken down into bits and pieces that would somehow connect with each other and combine into one fully functional sentence. 
There was more than one way to approach this problem.
First way was to create smaller pieces of text, that would show their meaning, but not really combine into a well formulated sentence. This was tested out for a while, but was not the optimum solution we wanted for our product.
The next way was to generate a premade set of combinations for the events. This would mean that every possible combination that was "wanted" in the game, would have to be made ahead of time. And with every option, there would have to be rewards and outcomes for each. Again for each outcome, there would have to be at least one for "success", one for "Neutral" and one for "Enemy". With all these pieces that had to be premade, the realization was that it was sort of the right way, but that it should be the other way around. The way to go would be to generate smaller blocks of text for all outcome and option pieces, and then have extra flavour that would tie it all together. This meant a drastic reduction in how much flavour would have to be premade, and the possible combinations would be far greater. 

The "block system" solution for the text was a very efficient way to generate the combinations. It ensured that more options and content could be added to the list by simply writing in a few lines of text. If another piece was wanted in the game, all that needed to be done in order to have it fully implemented, was to write down the name of the piece, some lines of flavour for it and maybe set a chance rate on it. With these few items added, the combination algorithm is able to create a lot of content with little effort. 
We felt that this was the way to go, as having larger blocks of flavour text could probably make the sentences more nuanced, but at the same time they would be very static and stiff, and would not necessarily combine with other parts of the game well. With the solution we ended up with here, we will not have that problem, as every item is loosely connected, and by the use of connection blocks, can be combined into more rigid and well-working sentences.

\subsection{Option combinations}
There are a multitude of ways to come up with a way to combine the options the players will have. Some that were touched will be discussed here.
The first way is to have a random selection. This would mean to just have a collection of all the possible requirements that would constitute an option, and having a number of them be selected at random.
Some good things about this, is that it reduces the need for expensive and complex computing, as it only requires a simple random value to be chosen. This can of course also be influenced by a seed or a bias counter leaning towards a specific option, however then it would not be completely random either.
The fact that it is so simplistic and random, means that several things can go wrong. The same option can be selected multiple times, there may not be enough options to choose from so that the options might not be diverse enough, and the overall feel that the options are based on anything might get lost by the overwhelming randomness, just to mention some.

\subsubsection{Locations}
Another way to generate the options is to have selection based on the location. That is locations as in the types of locations i.e. a mine, forest, lake, etc. Then the question becomes what can each of the locations hold? A mine might be rich in minerals, metals and rocks, while a forest can have different plant life and a lake can have hidden treasures in its depths. These are all thoughts that needs to be figured out for this setup to work. And if this is to be the chosen method for generating the event options, how many different possibilities are needed for each location, and then how many variations of each possibility is needed? The resulting collection can quickly become very large. 
That is not necessarily a bad thing, though. Having a large base of possible options is, in this game setting, a good thing. Lots of options means lots of variety. But then comes the issue which is the flavour. To be able to present the options to the players, there needs to be a substantial amount of flavour to go with the options. If not, then having this assortment, will quickly become obsolete and bland.

\subsubsection{Factions}
Basing the condition options on the factions can be an interesting way of generating them, because it opens up the possibility of lore behind each of the factions. To take one example from our game, the "Highbournes". The highbournes are made to be like elves. High and mighty with much knowledge about the nature and stars, and generally elves have a well known story attached to them. By using known types of mythical beings, one can get a good start and overview of where to begin. By looking into already existing books and stories about these creatures, one can get ideas and inspiration to what can be implemented in the solution. Elves might have high knowledge of potions and healing, so that would mean that a possible option could be to help them out with new recipes, materials that are foreign to them, or just introduce them to "modern" technology.
However, can you cross the border between known lore and made up new lore? Does it break the feeling of familiarity?
Yes, you can, and yes it would. It would be weird if in "The Lord of the Rings" (J. R. R. Tolkien, 1937-1949) you would see an Elf using a machine gun.
But then again, who is to say that new lore and new creatures can not be made. It is just important to make it clear that this is what is happening in that case.

While on the topic of factions, another idea on how to combine the options would be to use the standing the players have with each faction. It is closely based on the factions and their lore, as described above, but when taking a relationship into account, things can get different and interesting. Using the Highbournes as example again, if the players have a good standing with them, i.e. friendly, the options might be different from what they could be if they were enemies. A friend might want to lend out some resources, have their available people assist them in tasks and quest, whilst an enemy would perhaps steal resources from them, or destroy their buildings or kill their people. The differences are immense. Taking the relationship to each faction into account opens up for a different way of telling the story of the game to the players, and it also allows for drastic changes to be made. This is something that must be considered when thinking about how the game should look and feel. In this case, the feel should be more the one of exploration of unknown islands and locations, and the creatures living there are there, not necessarily for the lore itself, but more as an extra asset that the players hopefully can relate to. The factions might have wars against themselves, and they might see you, the outsiders, roaming around with mystical potions and weird machinery. If a war or battle is going on between two factions, would the players want to assist? Or just let them be? These are all thoughts that needs to be taken into consideration when basing options on factions and the players standing with them.


\subsubsection{Previous events}
One of the nicer things when combining a board game with a digital application, is the fact that there suddenly is access to memory. And with memory, comes alternatives and opportunities. A thought that instantly comes to mind, is basing later events and options on what has previously happened in the game. One can use statistics to see which options is more likely to be chosen, and build new ones of similar sort, or one could go the complete other way, and force the players to be more diverse and have them pick between options that they have been less likely to choose in the past. Finding patterns and frequent choices can be an option and a tool in designing new options. But using this method, requires that the text and feel of the options are coherent. If they do not make sense, the feel of the game can suffer from it. So going in this direction will take a lot of thought as to how everything should be formulated in order for it to be presented in a good way to the players. A thought on how to proceed in this direction, is to have building blocks, that are somewhat loosely based on the possible standings a player can have with each faction, then making sure that each of those blocks have some sort of meaning to both the faction and the game story itself. Making sure that they can all be combined with each other and persistently keeping in mind all the conditions, would be key in this approach.

As mentioned before having saved data is a big asset to a game, board games specifically. Saving up all the data of what has previously happened makes it possible to create new content that is taking into account what has previously happened. In a game like this, one could base the next options and outcomes on what the players have gotten during the events and actions leading up this far. If the players have been taking the easy option all the way, maybe it is time to challenge them and take away the possibility for an easy action. Maybe all the outcomes they have gotten so far has been negative? Having access to the saved data, and also \textit{when} the results occurred, can be a valuable asset, as it gives the opportunity to change the entire course of the game. It makes it possible to have adaptive difficulties, and one can also give the players the option to select and change difficulty on the go. Combining the options based on the previous results, can be tricky, however, if the options and the results do need to be directly linked to what has happened before, one has to take into account that it is not only the values that are presented to the players, but also the flavour texts. And the flavour text is what allows the players to become part of the \textit{world} that is the setting in the game itself. If there are major incoherences, the feeling of a polished experience can easily be broken. If going for this way of generating content, this fact must be in the back of the head. It can definitely be used as a way of generating the content, but there might need to be a secondary check whether or not the wording of the options and results are working and fitting. Grammars and the ordering of the words will be an important aspect when combining the generated contents into a finalized product.

\subsubsection{Difficulty}
Earlier there was a mention of changing the difficulty in the middle of the game. Another way of making the options, would be to do this difficulty change gradually as the players progress. Starting off easy, and then getting harder and harder. Or the other way around, easier and easier, if that is preferable. If this is what is wanted, there has to be some sort of scale that shows what constitutes hard, medium and easy. When this is established, the algorithms can be made into generating the content on a declining or increasing scale. How much is going to be changed, and how much it will be modified each turn, is then up to the scaling system itself, or the players, if they are given the possibility to set this themselves.

While on the topic of gradually changing the content, another way that comes up, is to increase the costs and rewards based on stages.
Each stage could be a finite amount of turns, or a stage can change to the next one when a certain threshold has been reached, be it turns, resources gained, resources lost, etc.

\subsubsection{Several factors}
The ways described above are singular ways of generating the options, however in a complete solution of the problem, one might want to combine two or more of these ways. 
We are using a combination of basing the options based on the location, as well as factions. Some of the events, i.e. the special events, are based on location, factions and standing. They get all this information from the previous events that has occurred, and by utilizing the memory of the application, it is able to give the players a \textit{shock factor} that would not be possible with a traditional board game. Containing the information that has happened before, opens up the possibility to startle the players with new content based on previous events. 
By mixing in an element of randomness into the mixture, it is possible to change the entire feel of an event, as the values might be slightly out of context, but still enough in context that it can be made sense of. All these mixtures is what makes it possible for multiple ways of handling the events. And by creating the options for each event as soon as the players enter them, it is possible to create varied outcomes as well. Each option can have an outcome based on how it is formulated, and by having this, the events can become very different and the range of which they impact the players is potentially increased. 
If the events are gradually changing, then the memory part can be a big influence. It allows the application to \textit{know} where in a game session it is, and from there, it can utilize different algorithms to change the difficulty, range of options and impact on the outcomes, that each event has. This can create a feeling of progression for the players, and make the feel of the game more consistent and make it feel like the game has more of a purpose to it.

\subsection{Layout of the map}
During development of the application, there was a discussion whether to use a pcg-algorithm in order to create the map, or to manually create it and have it saved. The conclusion was to use the L-System in order to be able to quickly generate maps, as having more than one map would give the players more replayability and diversity, and by using an L-System there was the possibility to mutate the rules of generation, and have a constantly changing layout. By changing the values such as the spreading angle of the island placement, the map would be different in looks, and by changing the number of iterations of expansion of the axiom, the map would become bigger or smaller. Then by introducing a random value for the angle and distancing of the islands, the maps could have a layout that would never look the same, and that would have a variation of turns and angles and distances from one island to another. However, by doing this, the calculation time for the L-System could become very large, and that could also ruin the player's interest for the game. So by compromising and rather create a multitude of different pre-set patterns, the execution time can easily be managed to be within the time frame that is required, and it allows for more controlled diversity within the layouts of the map.

A rather substantial problem with the L-System, is that it can become very large, very fast. This means that it can reduce the quality of the application, and consume too much of the resources of the device the application is running on. If the system is too big, and taking up too much resources, it can potentially freeze the system, and overheat the device. This is of course not a preferred scenario, and so it is better to have a controlled environment where construction of the rules and axioms of the different layouts to be produced by the system can be monitored and managed.

Our solution has a total of seven different and diverse map layouts, that are available within the code, however, for the sake of managing and testing the game and making sure the produced results and gameplay is coherent, only one of them will be used. This decision was made, because the need for some continuity was needed in order to make sure that all the aspects of the game; the flow, the board, the events, user interaction, etc. all were working as they should. 
Some of the other maps were smaller, with fewer possible destinations and events, and so they could be suited for a tutorial if that is desired. But for a full game, the need for a bigger map layout with all the islands in a set location is outweighing the need for diversity and changeable maps.


\subsection{Board layout}
During the development of Archipelago, the layout out the board changed many times. The original layout consisted of a partitioned grid of boxes, wherein the rooms would be placed. The partitioning were made so that each part had a different color that indicated the tier level of the castle. Each tier would require a certain amount of crystals in order to be functional. 
As the development process progressed, the layout changed. With each prototype came a new layout, and additional features were added. These features were cargo rooms for storing of the players' resources, a crystal bar for keeping track of the crystal tokens, an event box for when the players would send out crew tokens on events, and a building box and for putting crew and resource tokens in when managing the castle and building new rooms or upgrading existing ones. 
It would have been nice to have the finished version of the board printed onto a proper hard board, as usually used in traditional board games. The reason why this did not happen is due to the fact that the time available was not enough, and this being an educational project and not one for commercial sale, it was not necessary to have the board printed. The same goes for the tokens, although they were created of cardboard, so they were a bit more rigid.

\subsection{Tokens and rooms}
Archipelago has a multitude of tokens and rooms, and over all iterations of the development process, they have been redesigned, added or removed from the game. Each token that would be in the game had to have some sort of functionality and purpose, otherwise they would be rendered useless and feel like more of a nuisance than a contribution to the game. One aspect that ended up being completely removed from the game, was the diplomacy room and specialization tokens. Originally there were meant to be three types of event types; Gathering, Research and Diplomacy. However as the development of the game continued, and with feedback from playtests, the Diplomacy events ended up being scratched. It did not get the desired results that were wanted, and it did not give the experience we wanted for the game. Instead of having a diplomacy aspect to the game, the events would instead have diplomacy implemented through the use of special events and a faction system. This made the game more fluent and gave the game a better feel of being polished, as the faction system would both add to the story and setting of the game, as well as giving the feel of conflict in the game with each faction being against each other, and the players having to choose their sides in these conflicts either directly through special fighting events, or more indirectly through memory based special events.

\subsection{Theme}
\label{sec:theme}
There was a lot of different themes going around during construction of the project. The initial thought was Space and something in the lines of FTL: Faster Than Light. 
Other themes that came up were "Western Caravan" in a sort of "Mad Max" setting, "Pirates at sea" travelling from islands to islands, and plundering what they could find, "Magical Flying Castle" that would fly through a vast world of floating islands with unexplored areas of varying types and locations.
The last one was chosen. The reason for this choice, is that it gives us a feeling of familiarity, as it is in a fantasy setting, and most people are familiar with some sort of fantasy story, whether it is "The Lord of the Rings", "The Chronicles of Narnia" or other fantasy stories. Most games that are in this genre and has creatures or factions, usually have a connected base that is the basis for all fantasy. Usually it contains Orcs, Elves, Dwarves, etc. and this makes it easier for players to accept how the feel of the overall game story is set. 
Going with the theme of a flying castle roaming the skies, the setting itself would be some combination of the dark ages mixed with fantasy. When you see a stone castle, you usually think of the dark ages, and when that castle is flying, the thoughts go to a more made up world, a fantasy world. 
Having this fantasy aspect in the theme, allows there to be almost any types of creatures and areas, as they can be created from scratch and added into the story, as fantasy have room for any new things that might be created.

\subsection{Story}
In the start, there was not much story or concept of story, since it took a while before settling on a theme for the game. However, as we came up with different ideas for different themes, a part of the development was to have some sort of story basis in the back of our heads that would combine with the overall theme. Since we had the concept of a node-based system, every story and theme we would come up with, would have to support this. The world would be made up of a large overview of the map that had smaller "nodes" that the players would be able to visit. Each one of these nodes would then have smaller nodes within them. 
With a theme of pirates, the story would become something along the lines of the pirates would travel on the oceans from island to island, from port to port, and there they would be plundering all the villages and taverns they could find. In this case, each outer node would have smaller areas within it that would be the different places the island would have, like a tavern, village or other types of hubs. We were also considering the concept of space. Having a spaceship that would travel through the universe, visiting planet after planet, and exploring the areas of each one of these. Since the whole space scenario is a rather big one, and the science-fiction stories are many, coming up with an original and consistent story for the game, would be a rather immense task, and the risk of it being too generic or on the other side, too abstract, was something that had to be kept in mind. 
In the end, we landed with a more fantasy theme, with a floating castle that would travel around an unknown world where other people and factions would roam the lands and fight amongst each other. The story behind this scenario is that you, the player, are in control of this large floating castle, that is lost in a new and unexplored world. It is up to you to make sure that your castle and its crew are able to get to the destination safely. You will have to explore the vast world and its islands that are scattered around in all directions and expand upon your castle and try to power it up by getting more crystals like the ones that are powering up your castle. Along the way, you will encounter new races and factions, and see vast forests, huge lakes, old villages and factories, and it is up to you and your crew to gather what you can from these places and rebuild your castle and get home safely. You will make new allies and enemies along the way, so be careful not to aggravate the people you meet, or they might just attack your crew or your castle. Manage the castle efficiently, or you might just get stuck, floating in mid air in an unknown world, never to be able to return home.

\subsection{Gameplay}
\subsection{Connection between Board and App}
Having an app next to the board game, gives the players a point of interest, where they can look back and forth between the app and the board in order to get a tactical overview of any situation that may present itself. When an event is happening, and the players have to decide which option to select, they can quickly look to the board to see what they have, and then check back on the app to see which option will be the optimum choice.

Within the application, the events themselves are the main connection between it and the board. The events provide rewards and penalties on the board, and the board provides the players with the pieces needed for the available options in each event. 
Since this is a hybrid game, and not one of the two (analogue or digital), having this point of connection is essential, as it is what brings the two components together as a whole complete game. During the playtests this connection showed well, as the players were constantly looking back and forth between the two components in order to get as much information they could about the situation. This is something that is wanted in a hybrid game; the fact that both components are being view at the same time, and as a whole game. If only one of the components would have been dominant, the game play might have been different, and it is not what would have been wanted for this game. Archipelago is meant to be a game that is equally analogue and digital, and the two aspects should be viewed together as a whole complete set.


One could imagine switching the content from the board to the app and vice versa. Having the castle building mechanic on the app and having a world map to explore on the board.
This would allow the castle and its configuration to carry between games and let people pick up from a previous session easily. 
The game board would have a set of cards for events and some linear progression, but the castle and the the resource management could be in the app. 

There could perhaps be some sort of event generation on the app to take advantage of the computing power with the players inputting the location you are going to, with some other information from the board. 

The positive side of this configuration is that you can have the players can have a castle which can persist over several play-throughs, which could give rise to other interesting mechanics, and the construction of new rooms and could be linked to some content generation. 
The downside of this configuration could be that the event generation and the map layout would have to be done by cards and might become quite repetitive and predictable. This setup could also be viewed in comparison to Dungeons \& Dragons\cite{game:dnd}, where the players have their own characters with statistics and abilities that are written down on a paper sheet for reuse at another play session, as they level up and progress with each game. You could look at this setup in the same way, where the castle would be the character-sheet, and it would be saved and progressed on with each play session, until the castle is destroyed by the players losing the game.

\section{Collaborative game} 
Archipelago is after all a collaborative hybrid game. And this came through during the playtests. When people played the game for the first time, there were of course some minor confusions as to how the game was played, but after getting into it, they showed more and more interest in taking charge and communicating between the players. At one point there was a player who made a new meta game within, that she wanted to be the first of all the players to have a tier 3 room and be the "master" of that room. It is interesting to see which player behaviours are appearing when playing the game. And this case was rather pleasing, as it introduced a competitive element in the game, that was not intentionally placed there, and although it did not necessarily have any real impact on the game itself, it certainly had an impact on how the players enjoyed and played the game amongst themselves.
\section{The 2 phases of the game}

As described in the Final Prototype section (see \ref{sec:finalproto}), there are 2 main phases of the game; the management phase (see \ref{sec:p1}) and the exploration phase (see \ref{sec:p2}).\\When in the management phase, we noticed that some times the phase could end rather quickly. This usually came as a direct result of the players not having enough resources to do anything useful. Either they had to save up more resources, or they wanted to save them in order to possibly spend them during the events in case they were needed. This is of course a mechanic within the game, as this is a management kind of game (see \ref{sec:management}). It was rather interesting to see how the players would adapt to sudden changes and events that took place within the game, and how their tactics changed when the completed events yielded a penalty instead of a reward. Suddenly a room needed to be repaired, and that meant that they had to build the room that allows for that mechanic to happen, the mechanic's workshop.

The second phase, the exploration phase also proved to have varied behaviour of the players. During the initial first explorations, the new players were uncertain on which option to select, partly because they were new players, but also as they did not properly know the risks that comes with the different options. However as the players became more and more comfortable with the game and the rules, they started to become more determined, and sometimes took a more "aggressive" or "reckless" approach. Instantly wanting to take the more costly options, sometimes even without thinking about whether or not the controlling faction of the island were hostile. This meant that the outcomes had a greater chance of being negative, and when this happened to the players, frustration arose. 

It is good to see how the players change their attitude once something bad happens, like when they were penalized from an event, we could instantly see that they had to re-evaluate their moves in the upcoming rounds. 

Seeing that the players would change their tactics during the course of a game makes the game feel rather successful, as it made the players talk more amongst themselves, and it made for varied gameplay.

\section{A management-game}
\label{sec:management}
Although having elements of both exploration and strategy, the game itself is a management type game. What the game of Archipelago focuses most on, is managing the castle as you explore the wider world. Having this as the main mechanic of the games encourages the players to communicate and collaborate to make sure they are able to reach the winning conditions of the game. The game encourages the players to upgrade their castle and build rooms and upgrade them. But in order to be able to do so, they must gather the resources needed. This is done by completing events, and even there, the players have to manage who should send their player tokens out on the mission, and which missions they should complete in order to get the resources they need. Since the players have to manage their resources, and more importantly for the win - their player tokens, discussion and tactical thinking is being enforced onto the players. One player might want to take charge and be the "brains" behind the team, and that is O.K. because any player behaviour that causes the players to be social and interact amongst themselves is valuable for the game. We want the players of Archipelago to get into tactical discussions about how to manage their castle, what to build, what to upgrade, and we want them to be able to think ahead in the game and come to agreement on which events to pursue. 
\section{The result of the game}
As the development period is over, there are a number of things that can be said about the game that was created. Since the finished product is not meant to be a completely finished and polished game, the visual looks of it was not the most important aspect. The board itself is just printed on a piece of paper, and the tokens are made of cardboard. This would of course have been different if we had planned to make a more visually pleasing game. If this was the case, the board would have been made of proper hardboard materials, and the tokens might have been the same, maybe even some would have been in hard plastic. When it comes to the application, the same goes in terms of looks. We did not put too much pressure onto the graphics of the application, and there are still a few bugs here and there. This is all inevitable as the development period is only around 3-4 months. Looking over the code after having completed the deadline for developing, we found a lot of things that could have been done different e.g. duplicate code, redundant calls, etc. Again, this is to be expected, and these are all aspects that can be fixed and modified during future work.
When it comes to the algorithms used for PCG, we are pretty happy with them, as they do convey the concept of introducing PCG and its benefits in analogue games and further more onto hybrid games. The way we generate the events and the flavour of them proves that having a digital aspect in a game can be beneficial, and that it removes the need for having lots of cards and extra rules. As the game is at the end of the development period, it affords for repeated game play, and since the PCG algorithms have been implemented, the outcomes of each play session is different. This means that every time you play the game, the events are different. Of course there are similarities within them, and some times you might even get the same events as in a different game, but this is due to the fact that there is a very limited amount of building blocks that the PCG algorithms take into account. Had there been more of them, and more variations of each of them, the chances of a game having similar events would decrease. But for this project, and as proof of concept, we feel that the pieces implemented are sufficient.

\section{PCG contribution and its benefits}
\label{sec:pcgben}
What the PCG part did for this project, was to remove the need for the physical part of the game to have cards, map-board, a pre-written explanation on how to set up the map locations, and it removed the need for dice rolls. This being a collaborative game, the focus of the players needed to be more on each other and the \textit{story} of the game, rather than having to focus on reading from a piece of paper each turn, each time one rolls a die, and each time a card would be picked and had to be combined.

One of the biggest ways that PCG has contributed to the game, is to have given the game access to memory. This means that the game can suddenly surprise the players by presenting a newly generated event that is based on occurrences that happened maybe 15 turns ago. Unless the players have a book to write down every little detail of the story as the game unfolds, this would not be a very likely scenario to carry out, without the use of PCG. 
Having memory also opens up for the possibility of hiding information from players. Take the faction system for example: most of the information is hidden, and the only thing the players see is the little dialogue box that pops up when a faction's allegiance has been changed from one to another. This means that the only information the players have available is their current standing with the factions, and they will have to remember it themselves, as there is currently no way to see the current standing with any given faction, except for when said faction standing is changed. If the digital aspect of the game was not there, then the players would have to take note on the standing with each faction, and whenever a faction specific event would happen, they would have to use a different combination method for the events and the flavour, and maybe even have a separate deck of cards, which would mean more to keep track of, and more to carry around and set up in the game.
As for the events, the way PCG contributes, is to allow for quick gathering of information about the event details. The algorithm used generates varied results every time, and gives the game an expansion possibility that would not be the same if the events were selected from a pre-made static deck of event-cards. In order to expand upon the game and make it bigger and better, all that is needed, is to add more types of locations, factions, Options and outcomes, and flavour blocks for each of these into the XML file that contains all the information about the game, and then it would be like having a 500 piece deck of card added to the game.

When it comes to the map, the layout possibilities that PCG enables, are endless. Right now the system uses an L-System to generate the layout and place the islands at their correct locations. This is quick and efficient, and allows for endless ways to set up the map. By adding more rules, and specific interpretation logic for them, into the system, each new map can be made to have different experiences to them. You could maybe make a map that looks like the actual world? 
On top of just changing the map's layout, you can add quests and puzzles into the map itself. If combining the L-System with graph grammars, the map can be made so that one island has a quest assigned to it, and that quest could for instance have the players move towards another side of the map, to one specific island. The end island could then be hidden from the players completely, and only be showed/enabled when the players had reached a certain part of the quest line.

If the map was to be analogue and have all these possibilities, the physical weight of the game would potentially be enormous. Either all the map layouts would have to be able to be made with one set of pieces, or each layout would have to be made individually with their own pieces. And if there would be quests and quest-lines assigned to the maps, the rules for how they were played out would have to be thought out in advance, and they would probably make for a very \textit{similar} gameplay each time the game is played. PCG, however, enables the game to have varied contents every time.

By utilizing the memory of the application, the events and the content within them can be changed every time. It also makes it possible to have a difficulty curve within the game. By saving resources gained and lost on the events, the following events can use this information and take it into account when generating new ones. If the players have not received enough of one resource, the application can catch that, as it is saved in the memory, and then it can take countermeasures to make sure the game is able to progress. This would not be possible without the memory, and if the game was purely analogue, the players would either have to cheat and take extra resources without it being in the mechanics, or they could potentially lose the game, or have to start over. Of course, had this been a purely analogue game, the mechanics would have been made differently to account for things like this, but as it is not, the memory of the application serves as a valuable tool both for the game in its current state, and for possible future work on it.


\section{App vs. boardgame design challenges}
This section will discuss the problems and challenges of designing material for a multi-platform solution, and try to discuss possibilities within a hybrid game to explore the following elements.
When going over elements desired, there is both a question of where to put them, app or physical board, and how they will influence the other part of the game. 

\subsection{World map}
Early on, we came to the conclusion that we wanted the world map to be on the application. This would remove the need for the physical part of the game to have extra pieces to represent it. It also meant that the game could possibly have an endless amount of maps. By generating the map layout with the use of an L-System and interpretation logic, we could accomplish just that. As we kept developing the game, there were added several different layouts for the map. The need to experiment with the patterns and rules for the L-System arose as we wanted to try out different layouts. What was good with having multiple maps to choose from, was that it made the different game sessions feel different each time, by having a random map being selected at the start-up of the game. What could be done to further enhance the diversity of the layouts, is to introduce some sort of genetic mutation on the grammar of the L-System. This would allow the maps to be constantly changing, and with the use of a validation, or fitness function, the maps could be tailored to better fit the different types of players. However since the time scope of the project was as short as it was, this idea was left untouched as it would require extensive programming and testing, and it would be more or less out of scope in regards to the purpose of this thesis.

\subsection{Player representation in app}
The players needed to have a token of sorts in the app which quickly identified their location and presence.
As discussed in section \ref{sec:theme}, there were several ideas of how the gameplay should be tied to a theme. After the theme was solved, the question came whether the players should send expeditions out from a base or just move the base around.

After the final decision to have a moving base, a basic sprite were created to look like a floating castle, with the themed crystal hovering above it.

In terms of the app, the visuals of the individual tokens could easily be replaced with another sprite, whilst if it had been a board game that might have been more time consuming.
However, changing the method of which the players interacted with the app through this token, might take considerable time to change technically, whilst if it were only a board game, you could just decide that it was how it worked now.

\subsection{Tokens used in the application and on the board}
When coming up with the mechanics and the pieces needed in the game, we also needed to figure out which pieces and elements should be in the application part. Since the story of the game required \textit{people} to explore the islands in the world, and complete events on them, there was a need for the app to have player tokens as an input. Same goes for the resources that are used in the game. If an event required building material as a condition for the resolution, this would also have to be stored in some way in the app. One could argue that instead of having these parameters in the app, the algorithm behind the events could just generate several different and randomly connected outcomes. However since we want to explore the PCG aspect in connection with hybrid games, it is better to make sure that the application has the correct inputs and values so that it can generate content that actually influences the players' behaviour, and that is influenced by it.

\subsection{Focus on the app and the board}
The balance between the physical and digital part of the game as a whole needed to be kept intact. The word "hybrid game" itself would be rendered rather redundant if one of the parties would take over the players completely. If they are constantly looking at the board and neglecting the app, is there even a purpose for the app. The same goes for the board and if the players are constantly looking at the app, and not paying attention to the board. There needs to be a balance between the two. Either let the flow go from one to the other and then back in repetition, or have both aspects be equally important at any time in the game. Archipelago utilizes the first method, as the game consists of 2 phases. And in our game, the physical part is dependent on the app in order to give any purpose, while at the same time the app would be pointless without the board and the pieces to enable proper play.

\subsection{PCG replacing traditional features}
Whilst designing and programming the game and all the functionalities of the app, it was decided that there would not be any traditional cards in the game. At least not in the physical part of it. Instead we would have a way of introducing the "cards" in the application part. This decision was made to enhance the purpose of the initial problem statement proposal, that we want to explore the PCG aspect in hybrid games. Making the cards, or at least the text that would be on them, via the use of PCG algorithms would make for greater variation, and would give more purpose to the application part of the game. Also by the use of a digital device, we remove the need for the traditional die roll. Instead of having the players have one assigned "Dungeon Master", so to speak, that reads out the results based on what the die roll says, and whom has to keep looking down at a paper sheet in order to know the combinations, the use of the digital device and the PCG within it allows the players to have a much more smooth experience of the game, without having to stop every here and there in order to wait for one person to find the right combinations just so the players know the story and text of what happens.

\subsection{Story and theme}
In regards to having a story or theme for the game, the devices which we used played little to no role. 
This is mainly due to the focus on mechanics in the game, rather than the theme. This meant that no specific actions were taken in order to utilize the app to, in any way, push a narrative or theme.
As explained in section \ref{sec:theme}, the theme is interchangeable with only few tweaks to the layout of the application and the board game. 

One could however imagine a hybird game where the application generates some sort of narrative in the designed world. A short introduction to this story could then be displayed before the game begins. 

It could also be possible to have the app change theme by replacing the graphical elements. The change of the board is of course a more problematic matter, but one could image having a theme pack which could be a new physical board and a graphical package for the app.

\subsection{Graphics and visualization}
Since the theme of the game ended up on being a fantasy based dark-ages one, we wanted the look and feel of the UI to be somewhat rustic and stony. We ended up with making our own graphics for them. The background of the dialogue boxes and the buttons, even the player castle. We could possibly have found pre-made graphics online, but as they might be copyright protected, we came to the conclusion that it would be better to take a little extra time and do it ourselves. Since the main concept of our problem statement does not necessarily concern the graphics all that much, the creation of these graphics were not a big concern of ours, and was held off with until late in the project. It was more important to focus on game design and PCG implementation, and the fact that neither of the members within this project are graphical designers only enhanced this decision.


\section{Benefits of having memory in the app}
As described in section \ref{sec:pcgben}, having memory in the app is a big benefit to the game in total.
It opens up the possibility of having ever-changing events and content within the game, as the newly generated content can be based on previous content that has been saved into the memory of the app.
It allows the game to have player control in terms of the resources given to the players, along with possible negative effects to the players; penalties. The memory can influence the PCG algorithms in ways that would otherwise have to be done manually, e.g. if at the end of a turn, the players would have to type in how many resources they have of each type, and what they have spent, etc.
Since there is now memory in the application, calculations can be made to see which types of options the players select during an event. For instance, if one event has a third option that requires the players to have a specialization in healing, the application would then be able to calculate that the players have used at least 4 building materials, along with 2 alchemy points in order to get that room. The application would then do the calculations and save the result in the app, that the players now have 4 less materials, and 2 less alchemy points. Without the memory, this would not be possible, and the application would rather have to have set rules for how the events could be made up, or the players would have to give the app inputs so that it would know where to continue.
So one of the biggest benefits with having memory in the app, is that it allows for continuous generation of content that is directly connected to preceding events and content, and the current state of the players' resources.

\section{Possible alternatives to our solution}
One of the most obvious alternatives to our solution, is to create a complete board game, or a complete digital game, instead of using both as a hybrid. However this would not be in the scope of the project, as we want to explore the space between PCG and Boardgames by the use of an application and the making of a hybrid game.
As briefly mentioned earlier, it would be nice to take more use of the map, its layout and its possibilities. Creating quest lines and hidden events that would occur as the game progress. What would also be nice, is to have a route within the map, so that the players do not necessarily have to just go towards one node, but have one node at the start that is the first goal, then having other goals afterwards as they move through the map. 

\section{Team Dynamics}
Since the project group consisted of three members, one designer and two programmers, it was only natural that there would be a more intimate collaboration between the two programmers. We would all sit in the same closed off area and work, so that we would always be able to communicate issues and ideas, and give feedback to each other when needed. The programmers would usually work either side by side, or opposite of each other, and work on their specific tasks. Whenever problems or issues occurred, they would be able to simply look at the other person's screen and help with feedback or code review. The developer would also work closely with the programmers, as all the code that was being written had to originate from the concepts that the designer would come up with. During the brainstorming phase all parties would work together in order to come up with joint conclusions and ideas as to how the game would work. The designer communicated the ideas and needs for the project well, along with new updates and functionalities that would have to be implemented into the application in order to make the digital and the physical parts of the game come together and work as one whole game. 

Whenever a person was sick, or had personal errands that made it impossible to meet up in person, we would use the Slack \cite{prog:slack} communications program in order to stay up to date and in touch. Also by having access to Trello \cite{prog:trello}, we could plan all the tasks that needed to be done, and have an iterative development method, scrum, that we would follow. These programs were essential to the development process, as it allowed all the members of the group to easily be able to have a quick overview over all the tasks that needed to be done, and it made it possible to add new tasks as they arose, with everyone being able to get notified when that happened.

\section{Issues}
During the course of development, we did not have direct access to an android device for testing. This meant that as we developed and tested the application, we had to do so by the use of laptop computers. When we eventually got access to an android tablet, there was a rather substantial problem with the scale of the UI elements. The text was to small, and the dialogue boxes were not based on the resolution of the tablet's screen. So for the sake of actually being able to do proper play tests with the app in a portable device, we would have to manually go into the code and scale all the elements so that they would fit the screen of the device. A different approach that could have been taken, in hindsight, is to have used relative dimensions and made the scaling adaptive to the screen the application would be played on. However using the Unity3D game engine, all the elements are set to be a pixel based size by default. The UI elements are put into a canvas that acts as the place holder for all the child-elements. This canvas is then directly based on the size of the camera view frustum which when used by a mobile device or tablet, scales down pretty significantly. 
Another issue that was discovered by playing \textit{XCOM: The Board Game} \cite{game:xcomtbg} was that when playing a hybrid game, and using a mobile device to handle the digital part, if the program is too resource demanding it will drain the battery of the device. When we played this game, this happened to us. Fortunately we had a charger available, but not before the tablet shutting down completely. The good thing about the app for this game, was that it saved the progress as you went along, and was able to resume the game from where we left off when restarted.




