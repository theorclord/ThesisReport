\chapter{Discussion}
\label{sec:disc}
This chapter presents a discussion over the different choices made when designing \textit{Archipelago}, and the challenges of developing both the application and the analogue part of the game at the same time. Some aspects of the game will be left aside, in order to focus on the most important elements that need to be discussed before finalizing this project.

The knowledge gained after writing the background and analysis of already existing hybrid games will be one of the bases of the discussion. It will be used along with the theory on which the framework was based on. The choices made during the development will be discussed, both on a design and a technical perspective. Combining all those information with the knowledge acquired after the development of \textit{Archipelago} and the data gathered after the final playtest (and also the earlier ones) is one of the crucial aspect of this report, as learning by experimenting is what motivated this project in the first place. 

\section{Hybrid game}
When designing \textit{Archipelago} it was important to keep the balance between the physical and digital part of the game intact. The denomination of "hybrid game" itself would be rendered rather meaningless if one of the parties would completely overwhelm the general gameplay. If the players are constantly looking at the board and neglecting the application, there is not even a purpose for the application; the same goes for the analogue part if the players are constantly looking at the device, and not paying attention to the board. There needs to be a balance between the two. Either let the flow go from one to the other and then back in repetition, or have both aspects be equally important at any time in the game. 
Archipelago utilizes the first method, as the game consists of 2 phases. Tthe physical part is dependent on the application in order to give any purpose, while at the same time the application would be pointless without the board and the pieces to enable proper play. Several aspects need to be discussed to understand this perspective.

\subsection{Managing the resources and the base}
\label{sec:management}
Although having elements of both exploration and strategy, the game itself is a management type of game. What \textit{Archipelago} focuses the most on is managing the castle before exploring the wider world. Having this as the core mechanic of the game encourages the players to communicate and collaborate to make sure they are able to reach the winning conditions. The game demands the players to upgrade their castle, build rooms and upgrade them. But in order to be able to do so, they must gather the resources needed. This is done by completing events, and even then the players have to manage who should send their player tokens out on the mission, and which missions they should complete in order to get the resources they need. Since the players have to manage their resources, discussion and tactical thinking is being enforced onto the players. One player might want to take charge and be the "brains" behind the team. Although it is an interesting result to have during a playtest, a more polished version should offer arguments to the other players in order to balance the collaboration a bit more. An agreement between the participant has to be reached in order to take coherent decisions. Of course, this can also be seen as another perspective to base the design on: the gameplay could be based on a perfect collaboration, and at the same time the game could challenge the players by putting obstacles to the collaboration itself. 

Using PCG to provide the resources needed by the players to successfully manage the base also showed the problem of balancing, inherent to PCG-based games. In the case of \textit{Archipelago}, this has been a design problem that was never completely solved. The \textit{Cargo Hold} for example, was specifically designed to limit the number of resources that were received during the early game. This choice was made after noticing that players could have too many resources during an early stage of the game, thus reducing the importance of making interesting choices by making the game too easy. However, unlocking the \textit{Cargo Hold} space by powering the \textit{Crystal} (and then having to collect another rare resource) has shown the limits of such a system, and made the balancing even harder. Whereas this was a problem that was identified rather early in the development process, it has never been completely solved and also created problems when refining the core loop.

\subsection{The two phases of the game}

As described in the previous chapter (see section \ref{sec:finalproto}), there are 2 main phases of the game; the management phase (see section \ref{sec:p1}) and the exploration phase (see section \ref{sec:p2}).\\When managing the castle, it was noticed that some times this phase could end rather quickly. This usually came as a direct result of the players not having enough resources to do anything useful. Either they had to save up more resources, or they wanted to save them in order to possibly spend them during the events in case they were needed. This is of course a mechanic within the game, as it is based on management. It was rather interesting to see how the players would adapt to sudden changes and events that took place within the game, and how their tactics changed when the completed events yielded a penalty instead of a reward. Suddenly a room needed to be repaired, and that meant that they had to build the room that allows for that mechanic to happen, the mechanic's workshop. It is good to see how the players change their attitude once something bad happens, like when they were penalized from an event, we could instantly see that they had to re-evaluate their moves in the upcoming rounds.

The exploration phase also showed the variety of the different players' behaviour. During the initial first explorations, the new players were uncertain on which option to select, partly because they were new players, but also as they did not properly know the risks that come with the different options. However as the players became more and more comfortable with the game and the rules, they started to become more determined, and sometimes took a more "aggressive" or "reckless" approach. Instantly wanting to take the more costly options, sometimes even without thinking about whether or not the controlling faction of the island were hostile. This meant that the outcomes had a greater chance of being negative, and when this happened to the players, frustration arose. This problem can also be related to the state of the game itself. Feedback should be provided in order to correctly measure the risk associated to an event. While it was intended to tackle this design problem by comprehensively use clues based on text, the game in its current state is missing that feedback. This shows the importance of User Interface design in such a game. The two phases being interconnected, but based on components of different natures, the User Interface of the application must make the link between the two and clearly show it to the players so that they could base their discussions on meaningful information.

\subsection{Encouraging collaboration} 
Archipelago is a collaborative hybrid game. And this came through during the playtests. When people played the game for the first time, there were of course some minor confusions as to how the game was played, but after getting into it, they showed more and more interest in taking charge and communicating between the players. 

During a test, a player expressed that she wanted to be the first of all the players to build a level 3 room to then have the chance to become the "Master" of that area of expertise. It is interesting to see which player behaviours are appearing when playing the game. And this case was rather pleasing, as it introduced a competitive element in the game, that was not intentionally placed there, and although it did not necessarily have any real impact on the game itself, it certainly had an impact on how the players enjoyed and played the game amongst themselves. The game certainly encourages the discussion between the players and a competitive element within the collaboration proved to be a valuable part of the overall enjoyment. Having an incentive to further ones own goals, might bring forth more discussion around the table and enable the collaborative part.

However, this solution of creating collaborative gameplay has also shown the difficulty of designing a constructed specialization system. While it provided a nice feeling to the players as illustrated the last playtest and felt natural to implement in a PCG-based game (where even the content itself is constantly changing), it is a difficult design solution for the same reason. Because the content generated and their outcomes must take the specialization into account, designing the events over fluctuating roles stresses the problem of balancing the rewards even more. The same goes for the bonuses acquired after specializing. Still, having different roles in a game using a base building mechanic as well as resource gathering also makes the board a vital element to have. Correctly managing a base when there is direct proximity between the players is a totally different experience than collaborating on a computer. As illustrated during playtests, explaining a strategy can be done by moving the tiles on the board or showing the different tokens to use to the other players. While this collaboration could be helped thanks to a proper User Interface design in a computer game, an analogue way of planning strategy enables a typical tabletop game play experience.

\subsection{Desiging analogue components}
During the development of Archipelago, the layout out of the board changed many times. The original layout consisted of a partitioned grid of boxes, wherein the rooms would be placed. The partitioning were made so that each part indicated the different zones that were available for construction. With later prototypes, this way of representing used colours to properly differentiate the zones. Each zone would require a certain amount of crystals in order to be functional. 

As the development process progressed, the layout changed, along with the game mechanic. With each prototype came a new layout, and additional features were added. These features were cargo rooms for storing of the players' resources, a crystal bar for keeping track of the crystal tokens, an event box for when the players would send out crew tokens on events, and a building box and for putting crew and resource tokens in when managing the castle and building new rooms or upgrading existing ones. 

It proved to be hard to encourage the player's involvement with such an abstract board. All the elements used on the board are basically only here to support the game mechanics, and do not have a realistic equivalent. The closest element to a final layout is the shape of the construction zones of the board that basically uses the shape of a castle. The same goes for the tokens, although they were created of cardboard in the final prototype, so they were a bit more rigid and easier to handle for the players. Archipelago has several tokens and room tiles, and over all iterations of the development process, they have been redesigned, added or removed from the game. Each token that would be in the game had to have some sort of functionality and purpose, otherwise they would be rendered useless and feel like more of a nuisance than a contribution to the game. The playtests showed the importance of tactility and visuals in a board game. Many times the players have shown their alack of involvement that could have been partially solved with a nicer design.

\subsection{Connecting analogue and digital components}
Having an digital device next to the board game gives the players a point of interest. Playtests have shown the importance of using a portable device to develop such games. Using a computer and a mouse to perform the events proved to alter the flow of the game too much. When an event is happening, and the players have to decide which option to select, it proved to be more difficult to move back and forth from the computer to the board than it was with a digital device.

Within the application, the events themselves are the main connection between it and the board. The events provide rewards and penalties on the board, and the board provides the players with the pieces needed for the available options in each event. One of the prior concern when designing such interconnection was to build mechanics based on both components. This concern can be seen in the way that \textit{Archipelago} uses resources to perform the events. Originally, the different options did not require any specific resource to be performed. The players had to place one crew member in a room in order to unlock the different options. While this was an interesting base to merge analogue and digital mechanics, it was quickly abandoned when playtesting showed that the decisions were not based on meaningful information about the nature of the event (which is not yet generated in this phase). 
Since this is a hybrid game, and not one of the two (analogue or digital), having this point of connection is essential, as it is what brings the different components together as a whole complete game. During the playtests this connection showed well, as the players were constantly looking back and forth between the two components in order to get as much information they could about the situation. This is something that is wanted in a hybrid game; the fact that both components are being viewed at the same time. 


It is important to notice that not having a specific player in charge of the application can create problems. As shown during the last playtests, the players were confused about which of them should handle the inputs. It is true that the team was unaware of this problem while designing \textit{Archipelago}, as the game only used a portable device in its last iteration. With earlier versions, this problem was attributed to the fact that the player that was the closest to the computer would naturally handle all the inputs. This would have had much influence on the design as there might have been a specific player assigned to the use of the application. 

\section{PCG contribution and its benefits}
\label{sec:pcgben}
Having PCG allowed for this project to remove aspects from the game which could be seen as tedious; setting up the board, shuffling cards, calculating results, and rolling dice. Whilst some of these aspects are core to other games, they can also remove the focus from what is happening and disrupt the flow of the game.

Whilst designing and programming the game and all the functionalities of the app, it was decided that there would not be any traditional cards in the game. At least not in the physical part of it. Instead we would have a way of introducing the "cards" in the application part.
This is what became the events in the final application. This decision was made to enhance the purpose of the initial problem statement proposal, that we want to explore the PCG aspect in hybrid games.

The removal of these elements gave the players more time to interact with each other and strengthens the collaborative side of the game. The players are simply presented with a task and must discuss how to fix it, mainly in terms of reward and risk, not so much in terms of drawing cards and rolling dice.

\subsection{Events}
Choosing how the events should be structured and how to generate the flavour of the events, required several iterations, and the implementation evolved throughout the development process.

The final idea based itself on combining different attributes known about a given node into events which in some way utilized the attributes to generate their content. 

There are a multitude of ways to combine the these attributes and many different approaches to solving the problem of generating interesting events.

One could imagine at random getting the outcomes from the attributes available. 
This would mean you could have a collection of all possible events you can have, and simply pick randomly from them. 
This would ensure that there would be no bias towards any of the outcomes and have the possibilities be unpredictable. This also have the benefit of requiring the least amount computing power. 
However, it might provide weird and unforgiving outcomes to the players at all times, or pander to the players by giving them only positive outcomes.

Another way to steer the event generation is to have specific events for each input. This would give total control of the events to the designer and present a clear way to choose the correct options for the players' needs.
The downside is that the game would be very predictable and provide very little reason to replay it once you knew all the outcomes presented by the game.

We chose to have a compromise of sorts. The game can utilize any condition at any location, chosen at random in tiers, and the conditions are then used to select outcomes which have a random element by design, as the outcomes have several possibilities linked to each condition group.
This structure of events allows for an easy increase or decrease in the amount of randomness and possibilities, whilst having some structure as to what should be expected, preserving some sort of predictability. The hope is to have a greater re-playability from this structure as well as giving the players the ability to tactically select between different choices presented to them.

\subsubsection{Relation to game objects and flavour text}
The ordinary events do not use any information about the node from which it is generated, except the its type. 

The way the other variables influence the events is through the flavour text which is being generated around the outcomes. 

The reason the generation works this way around is to have a less rigid event structure, whilst still having relation to the game world.
One might argue you could base the events on the locations, but by using the same arguments as above this would create a more rigid structure. 

The argument for influencing the generation by the locations, as an example, is that the outcome might feel out of place for the play experience. In order to ensure the experience of play is unbroken, the flavour text was adapted to ensure context was given for the rewards of the event.

\subsubsection{Flavour text}
Even in the early stages of the project, there was the requirement for having some sort of flavour text which could be shown to the players. Showing it to the player required generating connected strings in some form that could relate to what was happening in game terms.
Then the question ahead was: How would this be done?
The first implementation started with having fully formed lines of text for every possible outcome and event, but realized that this was not beneficial, and that it would not create enough diversity to work as a proof of concept. 
The initial fully formed event text were rigid and would not scale well with the implementation of more pieces or with new combinations. Each time a new piece would be added, or a piece removed, would require new events to be fully written to account for the change. 

All the text strings needed to be broken down into bits and pieces that would somehow connect with each other and combine into one fully functional sentence. 
There was more than one way to approach this problem.

First way was to create smaller pieces of text, that would show their meaning, but not really combine into a well formulated sentence. This was tested out for a while, but was not the optimum solution for the final product.
The small pieces of text were random in their in the combined structure, giving a sense of no interconnection.

The next way was to generate a pre-made set of combinations for the events. This would mean that every possible combination that was "wanted" in the game, would have to be made ahead of time. And with every option, there would have to be rewards and outcomes for each. Again for each outcome, there would have to be at least one for "success", one for "Neutral" and one for "Enemy". 
With all these pieces that had to be pre-made, the realization was that it was sort of the right way, but that it should be the other way around. 

The way to go would be to generate smaller blocks of text for all outcome and option pieces, and then have extra flavour that would tie it all together. This meant a drastic reduction in how much flavour would have to be pre-made, and the possible combinations would be far greater. 

The \textit{block system} solution for the text was a very efficient way to generate the combinations. It ensured that more options and content could be added to the list by simply writing in a few lines of text. If another piece was wanted in the game, all that needed to be done in order to have it fully implemented, was to write down the name of the piece, some lines of flavour for it and maybe set a chance rate on it. With these few items added, the combination algorithm is able to create a lot of content with little effort.

\subsection{Benefits of having memory in the app}
In \textit{Archipelago}, memory is used in the way that it saves all the information from previous events.
What is great with this, is that it allows the game to suddenly surprise the players by presenting new events that are built up on previously completed events. This means that the players will recognize what the event is saying, and if they have been paying enough attention to the game, they will see that what they did maybe 5 turns ago, has influenced the game and the event that is occurring. 

The application can save data from previous events, and build upon that. This would be rather hard if the game was purely analogue. If it was just a board game without the digital application, the players would have to remember all the events themselves, which would mean that they would constantly be writing down notes during and after each encounter with an event.

The memory combined with the PCG is a truly wonderful combination, as it opens up for so many possible mechanics and extra features. These features and mechanics will also be elaborated on in the section \ref{sec:future}.

\subsection{World map}
The world map of the game where placed on the application, rather than having a physical board.
This removed the need for extra pieces for representing the world map. 
The idea was to be able to generate endless amounts of different and interesting maps. This was achieved through the use of a L-System, which with new logic could generate several map layouts.

Through the development, several different layouts for the map was added, each trying to see if we could add some diversity to the game.
The good thing about several map layouts, was that no game felt like a rerun of the old.

The solution has a total of seven different and diverse map layouts, that are available within the code, however, for the sake of managing and testing the game and making sure the produced results and gameplay is coherent, only one of them will be used. 
This decision was made, because the need for some continuity was needed in order to make sure that all the aspects of the game; the flow, the board, the events, user interaction, etc. all were working as they should. Some of the other maps were smaller, with fewer possible destinations and events, and so they could be suited for a tutorial if that is desired. But for a full game, the need for a bigger map layout with all the islands in a set location is outweighing the need for diversity and changeable maps.

If the map was to be analogue and have all the possibilities of the digital version, the physical weight of the game would potentially be enormous. 
Either all the map layouts would have to be able to be made with one set of pieces, or each layout would have to be made individually with their own pieces. 

As such the use of a L-system eliminates that requirement on the physical board game. The adaptability of the current solution could also scale well with new implementations.

A rather substantial problem with the L-System, is that it can become very large, very fast. This means that it can reduce the quality of the application, and consume too much of the resources of the device the application is running on. 
If the system is too big, and taking up too much resources, it can potentially freeze the system, and overheat the device. 
This is of course not a preferred scenario, and so it is better to have a controlled environment where construction of the rules and axioms of the different layouts to be produced by the system can be monitored and managed. As such, limiting the generation of the map is an essential part of the process of generating new maps, in order to ensure a stable platform.

\section{Theme and story}
There was a lot of different themes going around during construction of the project.
The initial thought was Space and something in the lines of FTL: Faster Than Light. Other themes that came up were "Western Caravan" in a sort of "Mad Max" setting, "Pirates at sea" travelling from islands to islands, and plundering what they could find; and "Magical Flying Castle" that would fly through a vast world of floating islands with unexplored areas of varying types and locations. 

The thing that all the themes had in common was the possibility of matching them to the setup of the game.	It was decide to find a theme after the core concepts of gameplay were in place, which led to limitations.

For the final theme, the "Magical Flying Castle" was chosen. The reason for this choice, is that it gives the feeling of familiarity, as it is in a fantasy setting, and most people are familiar with some sort of fantasy story, but also to have sometime which was original in form of the floating castle. 

Going with the theme of a flying castle roaming the skies, the setting itself would be some combination of the dark ages mixed with fantasy. When you see a stone castle, you usually think of the dark ages, and when that castle is flying, the thoughts go to a more made up world, a fantasy world. Having this fantasy aspect in the theme, allows there to solutions to almost any story or object which could be included in the game.
 
Initially there was not much of a concept of story, since it took a while before settling on a theme. 
However, since we had the concept of a node-based system, every story and theme we would come up with, would have to support this system. The world would be made up of a large overview of the map that had smaller "nodes" that the players would be able to visit. Each one of these nodes would then have smaller nodes within them.

With a theme of pirates, the story would become something along the lines of the pirates would travel on the oceans from island to island, from port to port, and there they would be plundering all the villages and taverns they could find. In this case, each outer node would have smaller areas within it that would be the different places the island would have, like a tavern, village or other types of hubs. 

In the end the story takes place in an unknown world where other people and factions would roam the lands and fight amongst each other, as you travel around trying to get home. 

The story behind this scenario is that you, the player, are in control of this large floating castle, that is lost in a new and unexplored world. 
It is up to you, as the player, to make sure that your castle and its crew are able to get to the destination safely. You will have to explore the vast world and its islands that are scattered around in all directions and expand upon your castle and try to power it up by getting more crystals like the ones that are powering up your castle.

Along the way, you will encounter factions, and see vast forests, huge lakes, old villages and factories, and it is up to you and your crew to gather what you can from these places and rebuild your castle and get home safely. 

You will make new allies and enemies along the way, so be careful not to aggravate the people you meet, or they might just attack your crew or your castle. Manage the castle efficiently, or you might just get stuck, floating in mid air in an unknown world, never to be able to return home.

The story allows for the players to feel invested in the game, and though there is not a great focus on this element, the story still serves to engage the players, and help them understand their goal.

\section{The final game}
As the development period is over, there are a number of things that can be said about the game that was created. Since the finished product is not meant to be a completely finished and polished game, the visual looks of it was not the most important aspect. 

The board itself is just printed on a piece of paper, and the tokens are made of cardboard. This would of course have been different if we had planned to make a more visually pleasing game. If this was the case, the board would have been made of proper hardboard materials, and the tokens might have been the same, maybe even some would have been in hard plastic. 

When it comes to the application, the same goes in terms of looks. We did not put too much pressure onto the graphics of the application, and there are still a few bugs here and there. This is all inevitable as the development period is only around 3-4 months. Looking over the code after having completed the deadline for developing, we found a lot of things that could have been done different e.g. duplicate code, redundant calls, etc.
Again, this is to be expected, and these are all aspects that can be fixed and modified during future work.

When it comes to the algorithms used for PCG, we are pretty happy with them, as they do convey the concept of introducing PCG and its benefits in analogue games and further more onto hybrid games. The way we generate the events and the flavour of them proves that having a digital aspect in a game can be beneficial, and that it removes the need for having lots of cards and extra rules. As the game is at the end of the development period, it affords for repeated game play, and since the PCG algorithms have been implemented, the outcomes of each play session is different. This means that every time you play the game, the events are different. Of course there are similarities within them, and some times you might even get the same events as in a different game, but this is due to the fact that there is a very limited amount of building blocks that the PCG algorithms take into account. Had there been more of them, and more variations of each of them, the chances of a game having similar events would decrease. But for this project, and as proof of concept, we feel that the pieces implemented are sufficient.

\section{App vs board game development}
When developing an application you have to deal the design of a game in relation to the possibilities and limitations provided by the interaction with and the capabilities of the device. 

When designing for a digital game there is a focus on the individual's experience interacting with the game in front of a digital device. 

For board game development there are similar concerns, however, each of which with slight modifications of the actual focus. For board games it is more common to have a focus on social experience, the interaction between the players during a game. It is also important for a board game to take the player-to-player communication into account, and consider the social elements of the game. 

When designing the mechanics for a board game, it is important to take note of the limitations presented in the analogue environment. Complex calculations and generation of content has to be limited to what can be accomplished using what is the most common methods; cards and dice rolls.

As a contrast, the application has the potential for solving more complex questions and doing several calculations for the players. This power gives the possibilities for new mechanics which might not be viable in typical board games. 

Those mechanics were all some which were encountered whilst working on and designing \textit{Archipelago}. It was clear that there were several things which had to be redone or reconfigured in order to account for either the digital part or the physical part of the game. And this was expected to happen, going into this project.

\subsection{Team Dynamics}
Since the project group consisted of three members, one designer and two programmers, it was only natural that there would be a more intimate collaboration between the two programmers. We would all sit in the same closed off area and work, so that we would always be able to communicate issues and ideas, and give feedback to each other when needed. The programmers would usually work either side by side, or opposite of each other, and work on their specific tasks. Whenever problems or issues occurred, they would be able to simply look at the other person's screen and help with feedback or code review. The developer would also work closely with the programmers, as all the code that was being written had to originate from the concepts that the designer would come up with. During the brainstorming phase all parties would work together in order to come up with joint conclusions and ideas as to how the game would work. The designer communicated the ideas and needs for the project well, along with new updates and functionalities that would have to be implemented into the application in order to make the digital and the physical parts of the game come together and work as one whole game. 

This way of working allowed for the quick exchange of ideas, which meant less downtime to test theories or get feedback from an idea.

\subsection{Issues}
During the course of development, we did not have direct access to an android device for testing. This meant that as we developed and tested the application, we had to do so by the use of laptop computers. 

When we eventually got access to an android tablet, there was a rather substantial problem with the scale of the UI elements. The text was to small, and the dialogue boxes were not based on the resolution of the tablet's screen. So for the sake of actually being able to do proper play tests with the app in a portable device, we would have to manually go into the code and scale all the elements so that they would fit the screen of the device. 

A different approach that could have been taken, in hindsight, is to have used relative dimensions and made the scaling adaptive to the screen the application would be played on. However using the Unity3D game engine, all the elements are set to be a pixel based size by default. The UI elements are put into a canvas that acts as the place holder for all the child-elements. This canvas is then directly based on the size of the camera view frustum which when used by a mobile device or tablet, scales down pretty significantly. 

Another issue that was discovered by playing \textit{XCOM: The Board Game} \cite{game:xcomtbg} was that when playing a hybrid game, and using a mobile device to handle the digital part, if the program is too resource demanding it will drain the battery of the device. When we played this game, this happened to us. Fortunately we had a charger available, but not before the tablet shutting down completely. The good thing about the app for this game, was that it saved the progress as you went along, and was able to resume the game from where we left off when restarted.
This problem of saving the instance of a game session, was a problem which unfortunately were not fixed in \textit{Archipelago}, which could lead to frustration of the player when/if a session is lost.
